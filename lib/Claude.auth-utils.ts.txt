// lib/auth-utils.ts
// Comprehensive authentication utilities with Supabase integration

import { supabase } from './supabase';
import { User, SignUpData, SignInData, UserRole } from './types';

// Postal code validation
export const GABRIOLA_POSTAL_CODE_PREFIX = 'V0R';

export function isGabriolaPostalCode(postalCode: string): boolean {
  return postalCode.toUpperCase().startsWith(GABRIOLA_POSTAL_CODE_PREFIX);
}

export function formatPostalCode(postalCode: string): string {
  // Remove spaces and uppercase
  const cleaned = postalCode.replace(/\s/g, '').toUpperCase();
  
  // Canadian format: A1A 1A1
  if (cleaned.length >= 6) {
    return `${cleaned.slice(0, 3)} ${cleaned.slice(3, 6)}`;
  }
  return cleaned;
}

export function validatePostalCode(postalCode: string): boolean {
  // Canadian postal code format: A1A 1A1
  const pattern = /^[A-Z]\d[A-Z]\s?\d[A-Z]\d$/i;
  return pattern.test(postalCode);
}

// Username validation
export function validateUsername(username: string): { valid: boolean; error?: string } {
  if (username.length < 3) {
    return { valid: false, error: 'Username must be at least 3 characters' };
  }
  if (username.length > 20) {
    return { valid: false, error: 'Username must be 20 characters or less' };
  }
  if (!/^[a-zA-Z0-9_]+$/.test(username)) {
    return { valid: false, error: 'Username can only contain letters, numbers, and underscores' };
  }
  return { valid: true };
}

// Email validation
export function validateEmail(email: string): boolean {
  const pattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return pattern.test(email);
}

// Password validation
export function validatePassword(password: string): { valid: boolean; error?: string } {
  if (password.length < 8) {
    return { valid: false, error: 'Password must be at least 8 characters' };
  }
  if (!/[A-Z]/.test(password)) {
    return { valid: false, error: 'Password must contain at least one uppercase letter' };
  }
  if (!/[a-z]/.test(password)) {
    return { valid: false, error: 'Password must contain at least one lowercase letter' };
  }
  if (!/[0-9]/.test(password)) {
    return { valid: false, error: 'Password must contain at least one number' };
  }
  return { valid: true };
}

// Sign up
export async function signUp(data: SignUpData): Promise<{ user: User | null; error: string | null }> {
  try {
    // Validate inputs
    if (!validateEmail(data.email)) {
      return { user: null, error: 'Invalid email address' };
    }

    const usernameValidation = validateUsername(data.username);
    if (!usernameValidation.valid) {
      return { user: null, error: usernameValidation.error! };
    }

    const passwordValidation = validatePassword(data.password);
    if (!passwordValidation.valid) {
      return { user: null, error: passwordValidation.error! };
    }

    if (!validatePostalCode(data.postal_code)) {
      return { user: null, error: 'Invalid postal code format' };
    }

    // Check if username already exists
    const { data: existingUsers, error: checkError } = await supabase
      .from('users')
      .select('username')
      .eq('username', data.username)
      .limit(1);

    // Ignore 406 errors during username check (table might be empty)
    if (existingUsers && existingUsers.length > 0) {
      return { user: null, error: 'Username already taken' };
    }

    // Format postal code
    const formattedPostalCode = formatPostalCode(data.postal_code);

    // Sign up with Supabase Auth
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email: data.email,
      password: data.password,
      options: {
        data: {
          full_name: data.full_name,
          username: data.username,
          postal_code: formattedPostalCode,
        },
      },
    });

    if (authError) {
      return { user: null, error: authError.message };
    }

    if (!authData.user) {
      return { user: null, error: 'Failed to create user' };
    }

    // Fetch the complete user profile
    const { data: userProfiles, error: profileError } = await supabase
      .from('users')
      .select('*')
      .eq('id', authData.user.id)
      .limit(1);

    const userProfile = userProfiles && userProfiles.length > 0 ? userProfiles[0] : null;

    if (profileError || !userProfile) {
      // Profile should be created by trigger, but if not, create it manually
      const { data: newProfiles, error: insertError } = await supabase
        .from('users')
        .insert({
          id: authData.user.id,
          full_name: data.full_name,
          username: data.username,
          postal_code: formattedPostalCode,
        })
        .select();

      const newProfile = newProfiles && newProfiles.length > 0 ? newProfiles[0] : null;

      if (insertError || !newProfile) {
        return { user: null, error: 'Failed to create user profile' };
      }

      return { user: { ...newProfile, email: data.email }, error: null };
    }

    return { user: { ...userProfile, email: data.email }, error: null };
  } catch (error: any) {
    return { user: null, error: error.message || 'An unexpected error occurred' };
  }
}

// Sign in
export async function signIn(data: SignInData): Promise<{ user: User | null; error: string | null }> {
  try {
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email: data.email,
      password: data.password,
    });

    if (authError) {
      return { user: null, error: authError.message };
    }

    if (!authData.user) {
      return { user: null, error: 'Failed to sign in' };
    }

    // Fetch user profile
    const { data: userProfiles, error: profileError } = await supabase
      .from('users')
      .select('*')
      .eq('id', authData.user.id)
      .limit(1);

    const userProfile = userProfiles && userProfiles.length > 0 ? userProfiles[0] : null;

    if (profileError || !userProfile) {
      return { user: null, error: 'User profile not found' };
    }

    // Check if user is banned
    if (userProfile.is_banned) {
      await supabase.auth.signOut();
      return { user: null, error: 'Your account has been banned. Please contact support.' };
    }

    // Update last active
    await supabase
      .from('users')
      .update({ last_active_at: new Date().toISOString() })
      .eq('id', authData.user.id);

    return { user: { ...userProfile, email: authData.user.email }, error: null };
  } catch (error: any) {
    return { user: null, error: error.message || 'An unexpected error occurred' };
  }
}

// Sign out
export async function signOut(): Promise<{ error: string | null }> {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) {
      return { error: error.message };
    }
    return { error: null };
  } catch (error: any) {
    return { error: error.message || 'An unexpected error occurred' };
  }
}

// Get current user
export async function getCurrentUser(): Promise<User | null> {
  try {
    const { data: { user: authUser } } = await supabase.auth.getUser();
    
    if (!authUser) {
      return null;
    }

    const { data: userProfiles } = await supabase
      .from('users')
      .select('*')
      .eq('id', authUser.id)
      .limit(1);

    const userProfile = userProfiles && userProfiles.length > 0 ? userProfiles[0] : null;

    if (!userProfile) {
      return null;
    }

    return { ...userProfile, email: authUser.email };
  } catch (error) {
    return null;
  }
}

// Check if user is logged in
export async function isLoggedIn(): Promise<boolean> {
  const user = await getCurrentUser();
  return user !== null;
}

// Permission checks
export function canPost(user: User | null): boolean {
  return user !== null && user.can_post && !user.is_banned;
}

export function canComment(user: User | null): boolean {
  return user !== null && user.can_comment && !user.is_banned;
}

export function canRSVP(user: User | null): boolean {
  return user !== null && user.can_rsvp && !user.is_banned;
}

export function canCreateEvents(user: User | null): boolean {
  return user !== null && user.can_create_events && !user.is_banned;
}

export function canModerateEvents(user: User | null): boolean {
  return user !== null && user.can_moderate_events && !user.is_banned;
}

export function canEditDirectory(user: User | null): boolean {
  return user !== null && user.can_edit_directory && !user.is_banned;
}

export function canIssueAlerts(user: User | null): boolean {
  return user !== null && user.can_issue_alerts && !user.is_banned;
}

export function canIssueAlertSeverity(
  user: User | null, 
  severity: 'info' | 'minor' | 'moderate' | 'major' | 'emergency'
): boolean {
  if (!user || !user.can_issue_alerts || user.is_banned) {
    return false;
  }

  const userLevel = user.alert_level_permission;
  
  // Permission hierarchy
  const hierarchy: Record<string, number> = {
    'none': 0,
    'minor': 1,      // Can issue: info, minor
    'moderate': 2,   // Can issue: info, minor, moderate
    'major': 3,      // Can issue: info, minor, moderate, major
    'emergency': 4   // Can issue: all levels
  };

  const severityLevel: Record<string, number> = {
    'info': 1,
    'minor': 1,
    'moderate': 2,
    'major': 3,
    'emergency': 4
  };

  return hierarchy[userLevel] >= severityLevel[severity];
}

export function isModerator(user: User | null): boolean {
  return user !== null && (user.role === 'moderator' || user.role === 'admin');
}

export function isAdmin(user: User | null): boolean {
  return user !== null && user.role === 'admin';
}

export function isResident(user: User | null): boolean {
  return user !== null && user.is_resident;
}

// Get user badge info
export function getUserBadge(user: User | null): { text: string; color: string; icon: string } | null {
  if (!user) return null;

  if (user.role === 'admin') {
    return { text: 'Admin', color: 'bg-red-500', icon: 'üëë' };
  }
  if (user.role === 'moderator') {
    return { text: 'Mod', color: 'bg-yellow-500', icon: '‚≠ê' };
  }
  if (user.is_resident) {
    return { text: 'Resident', color: 'bg-green-500', icon: '‚úì' };
  }
  return { text: 'Visitor', color: 'bg-blue-500', icon: 'üëã' };
}

// Update user profile
export async function updateUserProfile(
  userId: string,
  updates: Partial<User>
): Promise<{ success: boolean; error: string | null }> {
  try {
    const { error } = await supabase
      .from('users')
      .update(updates)
      .eq('id', userId);

    if (error) {
      return { success: false, error: error.message };
    }

    return { success: true, error: null };
  } catch (error: any) {
    return { success: false, error: error.message || 'Failed to update profile' };
  }
}

